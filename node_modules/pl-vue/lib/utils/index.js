function createId() {
  return Number((Math.random() + '').slice(2)).toString(32);
}
// #region 减少打包代码体积
/**
 * 警告信息
 * @param msg
 */
function printWarn(...msg) {
  console.warn(...msg);
}
/**
 * 获取字符串或数组的长度
 * @param o
 * @returns
 */
function len(o) {
  return o.length;
}
// #region

/**
 * 属于什么类型
 * @param o
 */
function isType(o) {
  return Object.prototype.toString.call(o).slice(8, -1);
}
/**
 * 函数是否是为类声明
 * @param func
 * @returns
 */
function isClass(func) {
  return func.toString().slice(0, 5) === 'class';
}
/**
 * 是否属于自己的属性
 * @param target
 * @param key
 * @returns
 */
function hasOwn(target, key) {
  return Object.prototype.hasOwnProperty.call(target, key);
}
/**
 * 判断两个值是否相等
 * @param val1
 * @param val2
 * @returns
 */
function isEquals(val1, val2) {
  if (isObject(val1) && isObject(val2)) {
    const keys1 = Object.keys(val1),
      keys2 = Object.keys(val2);
    if (len(keys1) !== len(keys2)) return false;
    for (const key of keys1) {
      if (!keys2.includes(key)) return false;
      const bool = isEquals(val1[key], val2[key]);
      if (!bool) return false;
    }
    return true;
  } else {
    return val1 === val2;
  }
}
/**
 * 是否为浏览器环境
 * @returns
 */
function isBrowser() {
  return typeof window === 'object';
}
/**
 * 是否为 object 类型，包含 class
 * @param obj
 * @returns
 */
function isObject(obj) {
  return typeof obj === 'object' && obj !== null;
}
/**
 * 是否为一个普通的对象
 * @param obj
 * @returns
 */
function isNormalObject(obj) {
  return isStrictObject(obj) || isType(obj) === 'Array';
}
/**
 * 是否为一个严格的对象
 * @param obj
 * @returns
 */
function isStrictObject(obj) {
  return isType(obj) === 'Object';
}
/**
 * 是 array 类型
 * @param obj
 * @returns
 */
function isArray(arr) {
  return Array.isArray(arr);
}
/**
 * 是 string 类型
 * @param obj
 * @returns
 */
function isString(text) {
  return typeof text === 'string';
}
function isFunction(value) {
  return typeof value === 'function';
}

/**
 * 异步执行一个函数
 * @param func
 */
function nextTick(func) {
  Promise.resolve().then(func);
}
// 兼容各种环境
// export function nextTick(func: Function) {
//   if (typeof Promise !== void 0) {
//     Promise.resolve().then(func as any);
//   } else if (typeof MutationObserver !== void 0) {
//     const ob = new MutationObserver(func as MutationCallback);
//     const textNode = document.createTextNode('0');
//     ob.observe(textNode, { characterData: true });
//     textNode.data = '1';
//   } else if (typeof process !== void 0) {
//     process.nextTick(func);
//   } else {
//     setTimeout(func, 0);
//   }
// }

class CustomWeakMap extends WeakMap {}

/**
 * 深度克隆
 * @param origin 被克隆对象
 * @param extend 扩展克隆方法
 */
function deepClone(origin, extend = {}) {
  const cache = new CustomWeakMap();
  const noCloneTypes = ['Null', 'Regexp', 'Date', 'WeakSet', 'WeakMap'];
  const specialClone = Object.assign({
    Function(func) {
      const newFunc = function (...args) {
        return func.apply(this, args);
      };
      newFunc.prototype = _deepClone(func.prototype);
      return newFunc;
    },
    Set(set) {
      const collect = new Set();
      for (const value of set) {
        collect.add(_deepClone(value));
      }
      return collect;
    },
    Map(map) {
      const collect = new Map();
      for (const [key, val] of map.entries()) {
        collect.set(key, _deepClone(val));
      }
      return collect;
    }
  }, extend);
  function _deepClone(_origin) {
    if (isBrowser() && _origin instanceof HTMLElement) {
      return _origin.cloneNode(true);
    }
    const type = isType(_origin);
    if (!['object', 'function'].includes(typeof _origin) || noCloneTypes.includes(type)) {
      return _origin;
    }
    // 防止环形引用问题（已经克隆过的对象不再进行克隆）
    if (cache.has(_origin)) {
      return cache.get(_origin);
    }
    // 特殊类型克隆处理
    if (specialClone[type]) {
      return specialClone[type](_origin);
    }
    // 创建一个新的对象
    const target = isArray(_origin) ? [] : {};
    Object.setPrototypeOf(target, Object.getPrototypeOf(_origin));
    // 设置缓存，该对象已经被克隆过
    cache.set(_origin, target);
    for (const key in _origin) {
      if (_origin.hasOwnProperty(key)) {
        target[key] = _deepClone(_origin[key]);
      }
    }
    return target;
  }
  return _deepClone(origin);
}
// #region 减少打包代码体积
/**
 * 合并对象
 * @param obj1
 * @param obj2
 * @returns
 */
function objectAssign(obj1, obj2) {
  return Object.assign({}, obj1, obj2);
}
// #region

// 下面自定义的一些遍历函数，没有考虑 hasOwn 和 this 指向的问题，因为这样会拖慢代码执行速度
// 也就是说不涉及到稀松数组的情况
/**
 * 一个自定义的性能比较好的 Array.forEach
 * @param array
 * @param callback
 */
function customForEach(array, callback) {
  let index = 0;
  while (index < len(array)) {
    callback(array[index], index);
    index++;
  }
}
/**
 * Array.findIndex
 * @param array
 * @param callback
 * @param self
 * @returns
 */
function customFindIndex(array, callback) {
  let index = 0;
  while (index < len(array)) {
    const item = array[index];
    if (callback(item, index)) {
      return index;
    }
    index++;
  }
  return -1;
}
/**
 * Array.find
 * @param array
 * @param callback
 * @param self
 * @returns
 */
function customFind(array, callback) {
  const index = customFindIndex(array, callback);
  return array[index];
}
/**
 * 二分查找
 * @param array       一个有序的数据
 * @param queryValue  查找内容
 * @param generateKey 返回一个可比较大小的值
 * @returns
 */
function binarySearch(array, queryValue, generateKey = v => v) {
  let start = 0;
  let end = len(array) - 1;
  while (start <= end) {
    const midden = Math.ceil((start + end) / 2);
    const val = array[midden];
    const item = generateKey(val);
    if (queryValue === item) {
      return midden;
    } else if (queryValue < item) {
      // 在左边
      end = midden - 1;
    } else if (queryValue > item) {
      // 在右边
      start = midden + 1;
    }
  }
  return -1;
}

export { CustomWeakMap, binarySearch, createId, customFind, customFindIndex, customForEach, deepClone, hasOwn, isArray, isBrowser, isClass, isEquals, isFunction, isNormalObject, isObject, isStrictObject, isString, isType, len, nextTick, objectAssign, printWarn };
