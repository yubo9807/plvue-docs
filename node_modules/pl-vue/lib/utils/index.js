/**
 * 属于什么类型
 * @param o
 */
function isType(o) {
  return Object.prototype.toString.call(o).slice(8, -1).toLowerCase();
}
/**
 * 从内存上看是否是一个对象
 * @param o
 */
function isMemoryObject(o) {
  return ['object', 'array'].includes(isType(o));
}
/**
 * 是否属于自己的属性
 * @param target
 * @param key
 * @returns
 */
function hasOwn(target, key) {
  return Object.prototype.hasOwnProperty.call(target, key);
}
/**
 * 判断两个值是否相等
 * @param val1
 * @param val2
 * @returns
 */
function isEquals(val1, val2) {
  if (isMemoryObject(val1) && isMemoryObject(val2)) {
    const keys1 = Object.keys(val1),
      keys2 = Object.keys(val2);
    if (keys1.length !== keys2.length) return false;
    for (const key of keys1) {
      if (!keys2.includes(key)) return false;
      const bool = isEquals(val1[key], val2[key]);
      if (!bool) return false;
    }
    return true;
  } else {
    return val1 === val2;
  }
}
/**
 * 是否为浏览器环境
 * @returns
 */
function isBrowser() {
  return typeof window === 'object';
}
// #region 减少打包代码体积
/**
 * 是 object 类型
 * @param obj
 * @returns
 */
function isObject(obj) {
  return isType(obj) === 'object';
}
/**
 * 是 array 类型
 * @param obj
 * @returns
 */
function isArray(arr) {
  return Array.isArray(arr);
}
/**
 * 是 string 类型
 * @param obj
 * @returns
 */
function isString(text) {
  return typeof text === 'string';
}
function isFunction(value) {
  return typeof value === 'function';
}
// #region

/**
 * 异步执行一个函数
 * @param func
 */
function nextTick(func) {
  Promise.resolve().then(func);
}
// 兼容各种环境
// export function nextTick(func: Function) {
//   if (typeof Promise !== void 0) {
//     Promise.resolve().then(func as any);
//   } else if (typeof MutationObserver !== void 0) {
//     const ob = new MutationObserver(func as MutationCallback);
//     const textNode = document.createTextNode('0');
//     ob.observe(textNode, { characterData: true });
//     textNode.data = '1';
//   } else if (typeof process !== void 0) {
//     process.nextTick(func);
//   } else {
//     setTimeout(func, 0);
//   }
// }

/**
 * 深度克隆
 * @param origin 被克隆对象
 */
function deepClone(origin) {
  const cache = new WeakMap();
  const noCloneTypes = ['null', 'weakset', 'weakmap'];
  const specialClone = {
    function(func) {
      const newFunc = function (...args) {
        return func.apply(this, args);
      };
      newFunc.prototype = _deepClone(func.prototype);
      return newFunc;
    },
    set(set) {
      const collect = new Set();
      for (const value of set) {
        collect.add(_deepClone(value));
      }
      return collect;
    },
    map(map) {
      const collect = new Map();
      for (const [key, val] of map.entries()) {
        collect.set(key, _deepClone(val));
      }
      return collect;
    }
  };
  function _deepClone(origin) {
    const type = isType(origin);
    if (!['object', 'function'].includes(typeof origin) || noCloneTypes.includes(type)) {
      return origin;
    }
    // 防止环形引用问题（已经克隆过的对象不再进行克隆）
    if (cache.has(origin)) {
      return cache.get(origin);
    }
    // 特殊类型克隆处理
    if (specialClone[type]) {
      return specialClone[type](origin);
    }
    // 创建一个新的对象
    const target = isArray(origin) ? [] : {};
    Object.setPrototypeOf(target, Object.getPrototypeOf(origin));
    // 设置缓存，该对象已经被克隆过
    cache.set(origin, target);
    for (const key in origin) {
      target[key] = _deepClone(origin[key]);
    }
    return target;
  }
  return _deepClone(origin);
}
// #region 减少打包代码体积
/**
 * 合并对象
 * @param obj1
 * @param obj2
 * @returns
 */
function objectAssign(obj1, obj2) {
  return Object.assign({}, obj1, obj2);
}
// #region

function createId() {
  return Number((Math.random() + '').slice(2)).toString(32);
}
// #region 减少打包代码体积
/**
 * 警告信息
 * @param msg
 */
function printWarn(...msg) {
  console.warn(...msg);
}
// #region

export { createId, deepClone, hasOwn, isArray, isBrowser, isEquals, isFunction, isMemoryObject, isObject, isString, isType, nextTick, objectAssign, printWarn };
