function createId() {
  return Number((Math.random() + '').slice(2)).toString(32);
}
// #region 减少打包代码体积
/**
 * 警告信息
 * @param msg
 */
function printWarn(...msg) {
  console.warn(...msg);
}
/**
 * 获取字符串或数组的长度
 * @param o
 * @returns
 */
function len(o) {
  return o.length;
}
// #region

/**
 * 属于什么类型
 * @param o
 */
function isType(o) {
  return Object.prototype.toString.call(o).slice(8, -1).toLowerCase();
}
/**
 * 函数是否是为类声明
 * @param func
 * @returns
 */
function isClass(func) {
  return func.toString().slice(0, 5) === 'class';
}
/**
 * 从内存上看是否是一个对象
 * @param o
 */
function isMemoryObject(o) {
  return ['object', 'array'].includes(isType(o));
}
/**
 * 是否属于自己的属性
 * @param target
 * @param key
 * @returns
 */
function hasOwn(target, key) {
  return Object.prototype.hasOwnProperty.call(target, key);
}
/**
 * 判断两个值是否相等
 * @param val1
 * @param val2
 * @returns
 */
function isEquals(val1, val2) {
  if (isMemoryObject(val1) && isMemoryObject(val2)) {
    const keys1 = Object.keys(val1),
      keys2 = Object.keys(val2);
    if (len(keys1) !== len(keys2)) return false;
    for (const key of keys1) {
      if (!keys2.includes(key)) return false;
      const bool = isEquals(val1[key], val2[key]);
      if (!bool) return false;
    }
    return true;
  } else {
    return val1 === val2;
  }
}
/**
 * 是否为浏览器环境
 * @returns
 */
function isBrowser() {
  return typeof window === 'object';
}
// #region 减少打包代码体积
/**
 * 是 object 类型
 * @param obj
 * @returns
 */
function isObject(obj) {
  return isType(obj) === 'object';
}
/**
 * 是 array 类型
 * @param obj
 * @returns
 */
function isArray(arr) {
  return Array.isArray(arr);
}
/**
 * 是 string 类型
 * @param obj
 * @returns
 */
function isString(text) {
  return typeof text === 'string';
}
function isFunction(value) {
  return typeof value === 'function';
}
// #region

/**
 * 异步执行一个函数
 * @param func
 */
function nextTick(func) {
  Promise.resolve().then(func);
}
// 兼容各种环境
// export function nextTick(func: Function) {
//   if (typeof Promise !== void 0) {
//     Promise.resolve().then(func as any);
//   } else if (typeof MutationObserver !== void 0) {
//     const ob = new MutationObserver(func as MutationCallback);
//     const textNode = document.createTextNode('0');
//     ob.observe(textNode, { characterData: true });
//     textNode.data = '1';
//   } else if (typeof process !== void 0) {
//     process.nextTick(func);
//   } else {
//     setTimeout(func, 0);
//   }
// }

class CustomWeakMap extends WeakMap {}

/**
 * 深度克隆
 * @param origin 被克隆对象
 * @param extend 扩展克隆方法
 */
function deepClone(origin, extend = {}) {
  const cache = new CustomWeakMap();
  const noCloneTypes = ['null', 'regexp', 'date', 'weakset', 'weakmap'];
  const specialClone = Object.assign({
    function(func) {
      const newFunc = function (...args) {
        return func.apply(this, args);
      };
      newFunc.prototype = _deepClone(func.prototype);
      return newFunc;
    },
    set(set) {
      const collect = new Set();
      for (const value of set) {
        collect.add(_deepClone(value));
      }
      return collect;
    },
    map(map) {
      const collect = new Map();
      for (const [key, val] of map.entries()) {
        collect.set(key, _deepClone(val));
      }
      return collect;
    }
  }, extend);
  function _deepClone(_origin) {
    if (isBrowser() && _origin instanceof HTMLElement) {
      return _origin.cloneNode(true);
    }
    const type = isType(_origin);
    if (!['object', 'function'].includes(typeof _origin) || noCloneTypes.includes(type)) {
      return _origin;
    }
    // 防止环形引用问题（已经克隆过的对象不再进行克隆）
    if (cache.has(_origin)) {
      return cache.get(_origin);
    }
    // 特殊类型克隆处理
    if (specialClone[type]) {
      return specialClone[type](_origin);
    }
    // 创建一个新的对象
    const target = isArray(_origin) ? [] : {};
    Object.setPrototypeOf(target, Object.getPrototypeOf(_origin));
    // 设置缓存，该对象已经被克隆过
    cache.set(_origin, target);
    for (const key in _origin) {
      if (_origin.hasOwnProperty(key)) {
        target[key] = _deepClone(_origin[key]);
      }
    }
    return target;
  }
  return _deepClone(origin);
}
// #region 减少打包代码体积
/**
 * 合并对象
 * @param obj1
 * @param obj2
 * @returns
 */
function objectAssign(obj1, obj2) {
  return Object.assign({}, obj1, obj2);
}
// #region

/**
 * 一个自定义的性能比较好的 Array.forEach
 * @param arr
 * @param callback
 */
function customForEach(arr, callback, self) {
  let index = 0;
  while (index < arr.length) {
    if (arr.hasOwnProperty(index)) {
      const item = arr[index];
      callback.apply(self, [item, index, self]);
    }
    index++;
  }
}

export { CustomWeakMap, createId, customForEach, deepClone, hasOwn, isArray, isBrowser, isClass, isEquals, isFunction, isMemoryObject, isObject, isString, isType, len, nextTick, objectAssign, printWarn };
