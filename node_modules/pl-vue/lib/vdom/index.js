import { isObject, isString, isFunction, objectAssign, createId, isArray, printWarn, isEquals, nextTick } from '../utils';
import { binding } from '../reactivity';

/**
 * 可以直接赋值给 dom 节点
 * @param value
 * @returns
 */
function isAssignmentValueToNode(value) {
  return ['string', 'number'].includes(typeof value) && value !== '';
}
/**
 * 可进行响应式改变的属性
 * @param attr
 */
function isReactiveChangeAttr(attr) {
  return !/^on/.test(attr);
}
/**
 * 是否为一个虚拟 dom 对象
 * @param o
 * @returns
 */
function isVirtualDomObject(o) {
  return isObject(o) && (isString(o.tag) || isFragment(o.tag));
}
/**
 * 是否为一个组件
 * @param o
 * @returns
 */
function isComponent(tag) {
  return isFunction(tag) && !isFragment(tag);
}
/**
 * 不进行渲染的值
 * @param value
 * @returns
 */
function noRenderValue(value) {
  return [void 0, null, '', true, false].includes(value);
}
// #region 减少打包代码体积
/**
 * 创建文本节点
 * @param text
 * @returns
 */
function createTextNode(text) {
  return document.createTextNode(text);
}
function appendChild(dom, child) {
  dom.appendChild(child);
}
// #endregion

function h(tag, attrs, ...children) {
  const tree = {
    tag,
    attrs: attrs || {},
    children
  };
  // 对组件做一些处理
  if (isComponent(tree.tag)) {
    // 高阶组件 props 传递
    if (tree.children.length === 0 && tree.attrs.children) {
      tree.children = tree.attrs.children;
    }
  }
  return tree;
}
/**
 * 获取组件 id
 * @param comp
 * @returns
 */
function getComponentId(comp) {
  return comp.prototype._id;
}
function Fragment({
  children
}) {
  return children;
}
const FragmentMark = Symbol('Fragment');
Fragment.prototype[FragmentMark] = FragmentMark;
/**
 * 是否是一个片段节点
 * @param tag
 * @returns
 */
function isFragment(tag) {
  return isFunction(tag) && tag.prototype[FragmentMark] === FragmentMark;
}

const compTreeMap = new WeakMap();
/**
 * 过滤掉元素，对组件进行收集
 * @param children
 * @param collect  递归参数，无需传递
 * @returns
 */
function filterElement(children, collect = []) {
  children.forEach(tree => {
    if (isObject(tree)) {
      if (isComponent(tree.tag)) {
        collect.push({
          comp: tree.tag,
          compId: getComponentId(tree.tag),
          props: objectAssign(tree.attrs, {
            children
          })
        });
      } else if (isAssignmentValueToNode(tree.tag)) {
        filterElement(tree.children, collect);
      }
    }
  });
  return collect;
}
/**
 * 获取一个组件下所有的子组件
 * @param comp    组件
 * @param collect 递归参数，无需传递
 * @returns
 */
function getSubComponent(comp, collect = []) {
  const arr = compTreeMap.get(comp) || [];
  collect.push(...arr);
  arr.forEach(val => {
    const arr = getSubComponent(val.comp);
    collect.push(...arr);
  });
  return collect;
}

let currentComp = null;
/**
 * 收集实例数据
 * @param comp
 * @param attrs
 * @param children
 */
function recordCurrentComp(comp) {
  currentComp = comp;
}
let currentExportData = null;
/**
 * 定义组件数据出口
 * @param data
 */
function defineExpose(data) {
  currentExportData = data;
}
/**
 * 收集组件导出数据
 * @param comp
 * @param attrs
 * @param children
 */
function collectExportsData(comp, attrs) {
  currentComp = comp;
  if ('ref' in attrs) {
    attrs.ref.value = currentExportData;
  }
  currentExportData = null;
}

/**
 * 当上锁时，所有的钩子都将无法注册
 */
let hookLock = false;
/**
 * 设置锁开关
 * @param bool
 */
function setLock(bool) {
  hookLock = bool;
}

const map$1 = new Map();
/**
 * 注册 onBeforeUnmount 钩子
 * @param comp 组件名
 * @param fn
 * @returns
 */
function onBeforeUnmount(fn) {
  if (hookLock) return;
  const key = getComponentId(currentComp);
  const arr = map$1.get(key) || [];
  const isExist = arr.some(func => func === fn);
  if (isExist) return;
  arr.push(fn);
  map$1.set(key, arr);
}
/**
 * 执行对应的 onBeforeUnmount 钩子
 * @param comp 组件名
 */
function triggerBeforeUnmount(comp) {
  const keys = getSubComponent(comp).map(val => val.compId);
  keys.unshift(getComponentId(comp));
  const funcs = [];
  keys.forEach(key => {
    const arr = map$1.get(key) || [];
    funcs.push(...arr);
    map$1.delete(key);
  });
  funcs.forEach(func => {
    func();
  });
}

const map = new Map();
/**
 * 注册 onUnmounted 钩子
 * @param comp 组件名
 * @param fn
 * @returns
 */
function onUnmounted(fn) {
  if (hookLock) return;
  const key = getComponentId(currentComp); // 在微队列之前与微队列之后拿到的 id 不一致
  const arr = map.get(key) || [];
  const isExist = arr.some(func => func === fn);
  if (isExist) return;
  arr.push(fn);
  map.set(key, arr);
}
/**
 * 执行对应的 onUnmounted 钩子
 * @param comp 组件名
 */
function triggerUnmounted(comp) {
  const keys = getSubComponent(comp).map(val => val.compId);
  keys.unshift(getComponentId(comp));
  const funcs = [];
  keys.forEach(key => {
    const arr = map.get(key) || [];
    funcs.push(...arr);
    map.delete(key);
  });
  funcs.forEach(func => {
    func();
  });
}

/**
 * 创建元素
 * @param tag
 * @param attrs
 * @param children
 * @returns
 */
function createElement(tag, attrs, children) {
  if (isString(tag)) {
    // 节点
    return createElementReal(tag, attrs, children);
  }
  if (isFragment(tag)) {
    // 节点片段
    return createElementFragment(children);
  }
  if (isComponent(tag)) {
    // 组件
    tag = tag;
    tag.prototype._id = createId();
    recordCurrentComp(tag);
    const props = objectAssign(attrs, {
      children
    });
    const tree = tag(props);
    collectExportsData(tag, attrs);
    if (isAssignmentValueToNode(tree)) {
      // 可能直接返回字符串数字
      return createTextNode(tree);
    }
    compTreeMap.set(tag, filterElement(tree.children)); // 收集组件
    return createElement(tree.tag, tree.attrs, tree.children);
  }
}
/**
 * 创建真实节点
 * @param tag
 * @param attrs
 * @param children
 * @returns
 */
function createElementReal(tag, attrs = {}, children = ['']) {
  if (isFragment(tag)) {
    return createElement(tag, attrs, children);
  }
  const el = document.createElement(tag);
  children.forEach(val => {
    if (noRenderValue(val)) return;
    // 原始值
    if (isAssignmentValueToNode(val)) {
      const textNode = createTextNode(val);
      textNode.nodeValue = val;
      appendChild(el, textNode);
      return;
    }
    // 响应式数据
    if (isFunction(val)) {
      const fragment = createElementFragment([val]);
      appendChild(el, fragment);
      return;
    }
    // 节点片段
    if (isArray(val)) {
      const fragment = createElementFragment(val);
      appendChild(el, fragment);
      return;
    }
    // 节点
    if (isVirtualDomObject(val)) {
      const node = createElementReal(val.tag, val.attrs, val.children);
      appendChild(el, node);
      return;
    }
    if (isObject(val) && isComponent(val.tag)) {
      const node = createElement(val.tag, val.attrs, val.children);
      appendChild(el, node);
      return;
    }
    printWarn(`render: 不支持 ${val} 值渲染`);
  });
  // attrs 赋值
  for (const attr in attrs) {
    const value = attrs[attr];
    if ([void 0, null].includes(value)) continue;
    if (attr.startsWith('data-')) {
      el.dataset[attr.slice(5)] = value;
      continue;
    }
    if (attr === 'ref') {
      value.value = el;
      continue;
    }
    if (attr === 'created' && isFunction(value)) {
      value(el);
      continue;
    }
    if (isFunction(value) && isReactiveChangeAttr(attr)) {
      binding(() => {
        el[attr] = value();
      });
      continue;
    }
    el[attr] = value;
  }
  // 对样式单独处理
  if (attrs.style && isObject(attrs.style)) {
    for (const prop in attrs.style) {
      const value = attrs.style[prop];
      if (isFunction(value)) {
        binding(() => el.style[prop] = value());
      } else {
        el.style[prop] = value;
      }
    }
  }
  return el;
}
/**
 * 创建节点片段
 * @param children
 * @returns
 */
function createElementFragment(children) {
  const fragment = document.createDocumentFragment();
  children.forEach(val => {
    if (noRenderValue(val)) return;
    // 原始值
    if (isAssignmentValueToNode(val)) {
      const textNode = createTextNode(val);
      textNode.nodeValue = val;
      appendChild(fragment, textNode);
      return;
    }
    // 响应式数据
    if (isFunction(val)) {
      reactivityNode(fragment, val);
      return;
    }
    // 节点片段
    if (isArray(val)) {
      const fragmentNode = createElementFragment(val);
      appendChild(fragment, fragmentNode);
      return;
    }
    // 节点
    if (isVirtualDomObject(val)) {
      const node = createElementReal(val.tag, val.attrs, val.children);
      appendChild(fragment, node);
      return;
    }
    // 组件
    if (isObject(val) && isComponent(val.tag)) {
      const node = createElement(val.tag, val.attrs, val.children);
      appendChild(fragment, node);
      return;
    }
    printWarn(`render: 不支持 ${val} 值渲染`);
  });
  return fragment;
}
/**
 * 创建一个节点
 * @param value
 * @returns
 */
function createNode(value) {
  // 文本节点
  if (isAssignmentValueToNode(value)) {
    return createTextNode(value);
  }
  // 节点
  if (isVirtualDomObject(value)) {
    return createElement(value.tag, value.attrs, value.children);
  }
  // 组件
  if (isObject(value) && isComponent(value.tag)) {
    return createElement(value.tag, value.attrs, value.children);
  }
}
/**
 * 查询备份数据中是否存在（二分）
 * @param arr
 * @param val
 * @returns
 */
function lookupBackupNodes(arr, val) {
  let start = 0;
  let end = arr.length - 1;
  while (start <= end) {
    var midden = Math.ceil((start + end) / 2);
    if (val === arr[midden].key) {
      return midden;
    } else if (val < arr[midden].key) {
      // 在左边
      end = midden - 1;
    } else if (val > arr[midden].key) {
      // 在右边
      start = midden + 1;
    }
  }
  return -1;
}
/**
 * 响应式节点变化
 * @param fragment
 * @param val
 */
function reactivityNode(fragment, val) {
  let backupNodes = [];
  let lockFirstRun = true; // 锁：第一次运行
  let parent = null;
  const textNode = createTextNode(''); // 用于记录添加位置
  appendChild(fragment, textNode);
  binding(() => {
    let value = val();
    if (value && isObject(value) && isFragment(value.tag)) {
      printWarn('不支持响应式节点片段渲染');
      return;
    }
    if (!isArray(value)) {
      value = [value];
    }
    value = value.filter(val => !noRenderValue(val));
    let i = 0;
    while (i < value.length) {
      let val = value[i];
      const index = lookupBackupNodes(backupNodes, i);
      if (index >= 0) {
        // 节点已经存在
        if (isEquals(val, backupNodes[index].tree)) {
          // 任何数据都没有变化
          i++;
          continue;
        }
        // 节点替换，重新备份
        const node = createNode(val);
        if (!node) {
          // 创建节点失败，有可能原节点被删除
          value.splice(index, 1);
          i++;
          continue;
        }
        const originTree = backupNodes[index].tree;
        isComponent(originTree.tag) && triggerBeforeUnmount(originTree.tag); // 组件卸载之前
        backupNodes[index].node.parentElement.replaceChild(node, backupNodes[index].node);
        if (isComponent(originTree.tag)) {
          // 组件卸载之后
          const comp = originTree.tag;
          triggerUnmounted(comp);
          compTreeMap.delete(comp);
        }
        backupNodes[index].tree = val;
        backupNodes[index].node = node;
      } else {
        // 节点不存在，追加节点
        const node = createNode(val);
        if (!node) {
          // 创建节点失败，有可能原节点被删除
          i++;
          continue;
        }
        if (lockFirstRun) {
          appendChild(fragment, node);
        } else if (backupNodes.length === 0) {
          parent ??= textNode.parentElement;
          parent.insertBefore(node, textNode.nextSibling);
        } else {
          const prevNode = backupNodes[backupNodes.length - 1].node;
          const lastNode = prevNode.nextSibling;
          prevNode.parentElement.insertBefore(node, lastNode);
        }
        backupNodes.push({
          key: i,
          tree: val,
          node
        });
      }
      i++;
    }
    // 检查有没有要删除的节点
    if (backupNodes.length > value.length) {
      for (let i = value.length; i < backupNodes.length; i++) {
        const originTree = backupNodes[i].tree;
        isComponent(originTree.tag) && triggerBeforeUnmount(originTree.tag); // 组件卸载之前
        backupNodes[i].node.remove();
        if (isComponent(originTree.tag)) {
          // 组件卸载之后
          const comp = originTree.tag;
          triggerUnmounted(comp);
          compTreeMap.delete(comp);
        }
      }
      backupNodes.splice(value.length, backupNodes.length - value.length);
    }
    lockFirstRun = false;
  });
}

/**
 * 创建 innerHTML，用于服务端渲染
 * @param tag
 * @param attrs
 * @param children
 */
function createHTML(tag, attrs = {}, children = ['']) {
  // 节点片段
  if (isFragment(tag)) {
    const props = objectAssign(attrs, {
      children
    });
    const h = tag(props);
    return createHTMLFragment(h);
  }
  // 组件
  if (isComponent(tag)) {
    const props = objectAssign(attrs, {
      children
    });
    const h = tag(props);
    return createHTML(h.tag, h.attrs, h.children);
  }
  // 属性
  let attrStr = '';
  for (const attr in attrs) {
    if (attr.startsWith('on') || attr === 'ref') continue;
    let value = isFunction(attrs[attr]) && isReactiveChangeAttr(attr) ? attrs[attr]() : attrs[attr];
    if (attr === 'className') {
      value && (attrStr += ` class="${value}"`);
      continue;
    }
    // 对样式单独做下处理
    if (attr === 'style' && isObject(value)) {
      for (const key in value) {
        if (isFunction(value[key])) {
          // 响应式数据
          value[key] = value[key]();
        }
      }
      value = '"' + JSON.stringify(value).slice(1, -1).replaceAll('"', '').replaceAll(',', ';') + '"';
    }
    attrStr += ` ${attr}="${value}"`;
  }
  // 子节点
  const subNodeStr = createHTMLFragment(children);
  return `<${tag}${attrStr}>${subNodeStr}</${tag}>`;
}
/**
 * 创建 innerHTML 片段
 * @param children
 * @returns
 */
function createHTMLFragment(children) {
  let text = '';
  children.forEach(val => {
    // 原始值
    if (isAssignmentValueToNode(val)) {
      text += val.toString();
      return;
    }
    // 节点片段
    if (isArray(val)) {
      text += createHTMLFragment(val);
      return;
    }
    // 响应式数据
    if (isFunction(val)) {
      const value = val();
      text += createHTMLFragment([value]);
      return;
    }
    // 节点 || 组件 || 虚拟节点
    if (isObject(val)) {
      text += createHTML(val.tag, val.attrs, val.children);
      return;
    }
    printWarn(`renderToString: 不支持 ${val} 值渲染`);
  });
  return text;
}

const collect$1 = [];
let isBeforeMount = false;
/**
 * 注册一个 onBeforeMount 钩子
 * @param fn
 */
function onBeforeMount(fn) {
  if (hookLock) return;
  if (isBeforeMount) {
    fn();
    return;
  }
  collect$1.push(fn);
}
/**
 * 执行所有 onBeforeMount 钩子
 */
function triggerBeforeMount() {
  collect$1.forEach(fn => {
    fn();
  });
  collect$1.length = 0;
  isBeforeMount = true;
}

const collect = [];
let isMounted = false;
/**
 * 注册一个 onMounted 钩子
 * @param fn
 */
function onMounted(fn) {
  if (hookLock) return;
  if (isMounted) {
    nextTick(fn);
    return;
  }
  collect.push(fn);
}
/**
 * 执行所有 onMounted 钩子
 */
function triggerMounted() {
  collect.forEach(fn => {
    fn();
  });
  collect.length = 0;
  isMounted = true;
}

/**
 * 创建组件虚拟 DOM 树的函数
 * @param param0
 * @returns
 */
function render({
  tag,
  attrs,
  children
}) {
  const dom = createElement(tag, attrs, children);
  // 执行钩子函数
  triggerBeforeMount();
  nextTick(triggerMounted);
  return dom;
}
/**
 * 服务端渲染函数
 * @param param0
 * @returns
 */
function renderToString({
  tag,
  attrs,
  children
}) {
  setLock(true);
  const html = createHTML(tag, attrs, children);
  setLock(false);
  return html;
}

export { Fragment, createElement, createElementFragment, createHTML, createHTMLFragment, defineExpose, h, onBeforeMount, onBeforeUnmount, onMounted, onUnmounted, render, renderToString };
