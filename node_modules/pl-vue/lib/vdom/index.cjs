'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var utils = require('../utils/index.cjs');
var reactivity = require('../reactivity/index.cjs');

/**
 * 可以直接赋值给 dom 节点
 * @param value
 * @returns
 */
function isAssignmentValueToNode(value) {
  return ['string', 'number'].includes(typeof value) && value !== '';
}
/**
 * 可进行响应式改变的属性
 * @param attr
 */
function isReactiveChangeAttr(attr) {
  return !/^on/.test(attr);
}
/**
 * 是否为一个真实 dom 对象
 * @param o
 * @returns
 */
function isRealNode(o) {
  return utils.isStrictObject(o) && utils.isString(o.tag);
}
/**
 * 是否为一个组件
 * @param o
 * @returns
 */
function isComponent(tag) {
  return utils.isFunction(tag) && !isFragment(tag);
}
/**
 * 是否为一个类声明组件
 * @param o
 * @returns
 */
function isClassComponent(comp) {
  return utils.isClass(comp) && comp.prototype && comp.prototype.render;
}
/**
 * 不进行渲染的值
 * @param value
 * @returns
 */
function noRenderValue(value) {
  return [void 0, null, '', true, false].includes(value);
}
/**
 * 连接 class
 * @param args 剩余参数，类名
 * @returns
 */
function joinClass(...args) {
  const results = [];
  utils.customForEach(args, val => {
    if (utils.isFunction(val)) val = val();
    if (isAssignmentValueToNode(val)) {
      results.push(val);
    }
  });
  return results.join(' ').trim().replace(/\s+/, ' ');
}
// #region 减少打包代码体积
/**
 * 创建文本节点
 * @param text
 * @returns
 */
function createTextNode(text) {
  return document.createTextNode(text);
}
function appendChild(dom, child) {
  dom.appendChild(child);
}
// #endregion

function h(tag, attrs, ...children) {
  const tree = {
    tag,
    attrs: attrs || {},
    children
  };
  // 对组件做一些处理
  if (isComponent(tree.tag)) {
    // 高阶组件 props 传递
    if (utils.len(tree.children) === 0 && tree.attrs.children) {
      tree.children = tree.attrs.children;
    }
  }
  return tree;
}
function Fragment({
  children
}) {
  return children;
}
const FragmentMark = Symbol('Fragment');
Fragment.prototype[FragmentMark] = FragmentMark;
/**
 * 是否是一个片段节点
 * @param tag
 * @returns
 */
function isFragment(tag) {
  // @ts-ignore
  return utils.isFunction(tag) && tag.prototype && tag.prototype[FragmentMark] === FragmentMark;
}

const compTreeMap = new utils.CustomWeakMap();
/**
 * 过滤掉元素，对组件进行收集
 * @param children
 * @param collect  递归参数，无需传递
 * @returns
 */
function filterElement(children, collect = []) {
  utils.customForEach(children, tree => {
    if (!utils.isObject(tree)) return;
    if (isComponent(tree.tag)) {
      collect.push({
        comp: tree.tag,
        props: utils.objectAssign(tree.attrs, {
          children
        })
      });
      utils.customForEach(tree.children, val => {
        if (isComponent(val)) {
          collect.push({
            comp: val,
            props: {}
          });
        }
      });
    } else if (isAssignmentValueToNode(tree.tag)) {
      filterElement(tree.children, collect);
    }
  });
  return collect;
}
/**
 * 获取一个组件下所有的子组件
 * @param comp    组件
 * @param collect 递归参数，无需传递
 * @returns
 */
function getSubComponent(comp, collect = []) {
  const arr = compTreeMap.get(comp) || [];
  collect.push(...arr);
  utils.customForEach(arr, val => {
    const arr = getSubComponent(val.comp);
    collect.push(...arr);
  });
  return collect;
}

let currentExportData = null;
/**
 * 收集组件导出数据
 * @param comp
 * @param attrs
 * @param children
 */
function collectExportsData(comp, attrs) {
  if ('ref' in attrs) {
    attrs.ref.value = currentExportData;
  }
  currentExportData = null;
}

const collect$1 = [];
/**
 * 执行所有 onBeforeMount 钩子
 */
function triggerBeforeMount() {
  utils.customForEach(collect$1, fn => fn());
  collect$1.length = 0;
}

const collect = [];
/**
 * 执行所有 onMounted 钩子
 */
function triggerMounted() {
  utils.customForEach(collect, fn => fn());
  collect.length = 0;
}

const map$1 = new utils.CustomWeakMap();
/**
 * 执行对应的 onBeforeUnmount 钩子
 * @param comp 组件名
 */
function triggerBeforeUnmount(comp) {
  const keys = getSubComponent(comp).map(val => val.comp);
  keys.unshift(comp);
  const funcs = [];
  utils.customForEach(keys, key => {
    const arr = map$1.get(key) || [];
    funcs.push(...arr);
    map$1.delete(key);
  });
  utils.customForEach(funcs, func => func());
}

const map = new utils.CustomWeakMap();
/**
 * 执行对应的 onUnmounted 钩子
 * @param comp 组件名
 */
function triggerUnmounted(comp) {
  const keys = getSubComponent(comp).map(val => val.comp);
  keys.unshift(comp);
  const funcs = [];
  utils.customForEach(keys, key => {
    const arr = map.get(key) || [];
    funcs.push(...arr);
    map.delete(key);
  });
  utils.customForEach(funcs, func => func());
}

class Static {
  constructor() {}
  /**
   * 树形结构拦截
   * @param tree
   */
  intercept(tree) {
    return tree;
  }
  /**
   * 服务端渲染函数
   * @param tree
   * @returns
   */
  renderToString(tree) {
    const html = this.createHTML(tree);
    return html;
  }
  /**
   * 创建 innerHTML，用于服务端渲染
   * @param tree
   */
  createHTML(tree) {
    const {
      tag,
      attrs,
      children
    } = this.intercept(tree);
    // 节点片段
    if (isFragment(tag)) {
      const props = utils.objectAssign(attrs, {
        children
      });
      const h = tag(props);
      return this.createHTMLFragment(h);
    }
    // 组件
    if (isComponent(tag)) {
      if (isClassComponent(tag)) {
        // @ts-ignore
        const t = new tag({
          ...attrs,
          children
        });
        return this.createHTML(t.render.bind(t));
      }
      const props = utils.objectAssign(attrs, {
        children
      });
      const newTree = tag(props);
      return this.createHTML(newTree);
    }
    // 属性
    let attrStr = '';
    for (const attr in attrs) {
      if (attr.startsWith('on') || ['ref', 'created'].includes(attr)) continue;
      let value = utils.isFunction(attrs[attr]) && isReactiveChangeAttr(attr) ? attrs[attr]() : attrs[attr];
      if (utils.isString(tag) && ['innerHTML', 'innerText', 'textContent'].includes(attr)) {
        children[0] = value;
        continue;
      }
      if (attr === 'className') {
        value && (attrStr += ` class="${joinClass(...[value].flat())}"`);
        continue;
      }
      // 对样式单独做下处理
      if (attr === 'style' && utils.isStrictObject(value)) {
        for (const key in value) {
          if (utils.isFunction(value[key])) {
            // 响应式数据
            value[key] = value[key]();
          }
        }
        value = '"' + JSON.stringify(value).slice(1, -1).replace(/"/g, '').replace(/,/g, ';') + '"';
      }
      attrStr += ` ${attr}="${value}"`;
    }
    // 子节点
    const subNodeStr = this.createHTMLFragment(children);
    return `<${tag}${attrStr}>${subNodeStr}</${tag}>`;
  }
  /**
   * 创建 innerHTML 片段
   * @param children
   * @returns
   */
  createHTMLFragment(children) {
    let text = '';
    utils.customForEach(children, val => {
      if (noRenderValue(val)) return;
      // 原始值
      if (isAssignmentValueToNode(val)) {
        text += val.toString();
        return;
      }
      // 节点片段
      if (utils.isArray(val)) {
        text += this.createHTMLFragment(val);
        return;
      }
      // 响应式数据
      if (utils.isFunction(val)) {
        const value = val();
        text += this.createHTMLFragment([value]);
        return;
      }
      // 节点 || 组件 || 虚拟节点
      if (utils.isStrictObject(val)) {
        text += this.createHTML(val);
        return;
      }
    });
    return text;
  }
}

class Structure extends Static {
  #binding; // 响应式函数
  constructor(option) {
    super();
    this.#binding = option.binding;
  }
  /**
   * 创建组件虚拟 DOM 树的函数
   * @param param0
   * @returns
   */
  render(tree) {
    const dom = this.createElement(tree);
    // 执行钩子函数
    triggerBeforeMount();
    utils.nextTick(triggerMounted);
    return dom;
  }
  /**
   * 创建元素
   * @param tree
   * @param
   * @returns
   */
  createElement(tree) {
    const {
      tag,
      attrs,
      children
    } = this.intercept(tree);
    // 节点
    if (utils.isString(tag)) {
      return this.createRealNode(tag, attrs, children);
    }
    // 节点片段
    if (isFragment(tag)) {
      return this.createNodeFragment(children);
    }
    // 组件
    if (isComponent(tag)) {
      return this.createComponent(tag, attrs, children);
    }
  }
  /**
   * 组件生成节点
   * @param tag
   * @param attrs
   * @param children
   * @returns
   */
  createComponent(tag, attrs, children) {
    // 类组件
    if (isClassComponent(tag)) {
      // @ts-ignore
      const t = new tag({
        ...attrs,
        children
      });
      tag = t.render.bind(t);
    }
    // 组件
    const props = utils.objectAssign(attrs, {
      children
    });
    const tree = tag(props);
    collectExportsData(tag, attrs);
    if (isAssignmentValueToNode(tree)) {
      // 可能直接返回字符串数字
      return createTextNode(tree);
    }
    compTreeMap.set(tag, filterElement([tree, ...tree.children])); // 收集组件
    return this.createElement(tree);
  }
  /**
   * 创建真实节点
   * @param tag
   * @param attrs
   * @param children
   * @returns
   */
  createRealNode(tag, attrs = {}, children = ['']) {
    const el = document.createElement(tag);
    // created 和 children 中同时具备相同的值，删掉 children 中的值
    const created = attrs.created;
    if (utils.isFunction(created)) {
      const index = utils.customFindIndex(children, val => val === created);
      index >= 0 && children.splice(index, 1);
    }
    utils.customForEach(children, tree => {
      const val = this.intercept(tree);
      if (utils.isFunction(val)) {
        const fragment = this.createNodeFragment([val]);
        appendChild(el, fragment); // 响应式数据交给节点片段去处理
      } else {
        this.#nodeMount(el, val);
      }
    });
    // attrs 赋值
    for (const attr in attrs) {
      this.#attrAssign(el, attr, attrs[attr]);
    }
    // 对样式单独处理
    if (attrs.style && utils.isStrictObject(attrs.style)) {
      for (const prop in attrs.style) {
        const value = attrs.style[prop];
        if (utils.isFunction(value)) {
          this.#binding(() => el.style.setProperty(prop, value()));
        } else {
          el.style[prop] = value;
        }
      }
    }
    return el;
  }
  /**
   * 创建节点片段
   * @param children
   * @returns
   */
  createNodeFragment(children) {
    const fragment = document.createDocumentFragment();
    utils.customForEach(children, tree => {
      const val = this.intercept(tree);
      if (utils.isFunction(val)) {
        this.#reactivityNode(fragment, val); // 响应式数据挂载
      } else {
        this.#nodeMount(fragment, val);
      }
    });
    return fragment;
  }
  /**
   * 节点挂载
   * @param el
   * @param val
   */
  #nodeMount(el, val) {
    if (noRenderValue(val)) return;
    // 节点片段
    if (utils.isArray(val)) {
      const fragment = this.createNodeFragment(val);
      appendChild(el, fragment);
      return;
    }
    if (isAssignmentValueToNode(val) || utils.isStrictObject(val)) {
      const node = this.#createNode(val);
      appendChild(el, node);
      return;
    }
  }
  /**
   * 创建一个节点
   * @param value
   * @returns
   */
  #createNode(value) {
    // 文本节点
    if (isAssignmentValueToNode(value)) {
      return createTextNode(value);
    }
    // 节点
    if (isRealNode(value)) {
      return this.createRealNode(value.tag, value.attrs, value.children);
    }
    // 节点片段
    if (isFragment(value.tag)) {
      return this.createNodeFragment(value.children);
    }
    // 组件
    if (isComponent(value.tag)) {
      return this.createComponent(value.tag, value.attrs, value.children);
    }
  }
  /**
   * 属性赋值
   * @param el
   * @param attr
   * @param value
   */
  #attrAssign(el, attr, value) {
    // 自定义属性
    if (attr === 'ref' && utils.isStrictObject(value)) {
      value.value = el;
      return;
    }
    if (attr === 'created' && utils.isFunction(value)) {
      value(el);
      return;
    }
    if (attr === 'className' && utils.isArray(value)) {
      this.#binding(() => {
        el[attr] = joinClass(...value);
      });
      return;
    }
    // 一般属性赋值
    let assgin = val => el[attr] = val;
    // 特殊属性处理
    if (attr === 'className') {
      assgin = val => el[attr] = joinClass(val);
    } else if (attr.startsWith('data-')) {
      assgin = val => el.dataset[attr.slice(5)] = val;
    }
    // 响应式数据
    if (isReactiveChangeAttr(attr) && utils.isFunction(value)) {
      this.#binding(() => assgin(value()));
    } else {
      assgin(value);
    }
  }
  /**
   * 响应式节点变化
   * @param fragment
   * @param func
   */
  #reactivityNode(fragment, func) {
    let backupNodes = [];
    let lockFirstRun = true; // 锁：第一次运行
    let parent = null;
    const textNode = createTextNode(''); // 用于记录添加位置
    appendChild(fragment, textNode);
    this.#binding(() => {
      let value = func();
      if (value && utils.isObject(value) && isFragment(value.tag)) {
        return;
      }
      if (!utils.isArray(value)) value = [value];
      value = value.filter(val => !noRenderValue(val));
      let i = 0;
      while (i < utils.len(value)) {
        let val = value[i];
        const index = utils.binarySearch(backupNodes, i, v => v.key);
        if (index >= 0) {
          // 节点已经存在
          if (utils.isEquals(val, backupNodes[index].tree)) {
            // 任何数据都没有变化
            i++;
            continue;
          }
          // 节点替换，重新备份
          const node = this.#createNode(val);
          if (!node) {
            // 创建节点失败，有可能原节点被删除
            value.splice(index, 1);
            i++;
            continue;
          }
          const originTree = backupNodes[index].tree;
          isComponent(originTree.tag) && triggerBeforeUnmount(originTree.tag); // 组件卸载之前
          backupNodes[index].node.parentElement.replaceChild(node, backupNodes[index].node);
          if (isComponent(originTree.tag)) {
            // 组件卸载之后
            const comp = originTree.tag;
            triggerUnmounted(comp);
            compTreeMap.delete(comp);
          }
          backupNodes[index].tree = val;
          backupNodes[index].node = node;
        } else {
          // 节点不存在，追加节点
          const node = this.#createNode(val);
          if (!node) {
            // 创建节点失败，有可能原节点被删除
            i++;
            continue;
          }
          if (lockFirstRun) {
            appendChild(fragment, node);
          } else if (utils.len(backupNodes) === 0) {
            parent ??= textNode.parentElement;
            parent.insertBefore(node, textNode.nextSibling);
          } else {
            const prevNode = backupNodes[utils.len(backupNodes) - 1].node;
            const lastNode = prevNode.nextSibling;
            prevNode.parentElement.insertBefore(node, lastNode);
          }
          backupNodes.push({
            key: i,
            tree: val,
            node
          });
        }
        i++;
      }
      // 检查有没有要删除的节点
      if (utils.len(backupNodes) > utils.len(value)) {
        for (let i = utils.len(value); i < utils.len(backupNodes); i++) {
          const originTree = backupNodes[i].tree;
          isComponent(originTree.tag) && triggerBeforeUnmount(originTree.tag); // 组件卸载之前
          // @ts-ignore 节点片段无法删除
          backupNodes[i].node.remove();
          if (isComponent(originTree.tag)) {
            // 组件卸载之后
            const comp = originTree.tag;
            triggerUnmounted(comp);
            compTreeMap.delete(comp);
          }
        }
        backupNodes.splice(utils.len(value), utils.len(backupNodes) - utils.len(value));
      }
      lockFirstRun = false;
    });
  }
}

class App extends Structure {
  constructor(option) {
    super(option);
    this.option = option;
  }
  use(plugin) {
    plugin.install(this);
    return this;
  }
  version = '0.6.10';
  /**
   * 数据拦截
   */
  intercept(tree) {
    if (tree && utils.isString(tree.tag)) {
      const globalComp = this.#compMap.get(tree.tag);
      if (globalComp) {
        tree.tag = globalComp;
      }
    }
    return tree;
  }
  // #region 全局组件
  #compMap = new Map();
  /**
   * 注册全局组件
   * @param name
   * @param Comp
   */
  component(name, Comp) {
    this.#compMap.set(name, Comp);
    return this;
  }
}
/**
 * 创建应用
 * @param option
 * @returns
 */
function createApp() {
  return new App({
    binding: reactivity.binding
  });
}

exports.Fragment = Fragment;
exports.Static = Static;
exports.Structure = Structure;
exports.createApp = createApp;
exports.h = h;
