'use strict';

var utils = require('../utils/index.cjs');

let func = null;
const funcsMap = new WeakMap(); // 收集依赖的 map 集合
/**
 * 绑定响应式对象
 * @param fn 将响应式对象写在 fn 内，该对象重新赋值时会自行触发 fn()
 * 当返回 true 时，该函数将在依赖收集中删除，避免占用过多的内存
 */
function binding(fn) {
  func = fn;
  fn(); // 自执行触发 get 方法，方法被保存
  func = null;
}
/**
 * 依赖收集
 * @param key 存入 funcsMap 的键
 */
function dependencyCollection(key) {
  const funcs = funcsMap.get(key) || [];
  const bool = funcs.some(fn => func === fn); // 是否有重复存在的函数
  if (func && !bool) {
    funcs.push(func);
    funcsMap.set(key, funcs);
  }
}
/**
 * 派发更新
 * @param key 存入 funcsMap 的键
 */
function distributeUpdates(key) {
  const funcs = funcsMap.get(key);
  funcs && utils.customForEach(funcs, (fn, index) => {
    const del = fn();
    // 清理下内存，将不用的函数删除
    if (del === true) {
      funcs.splice(index, 1);
      funcsMap.set(key, funcs);
    }
  });
}
/**
 * 回收依赖，清空当前已收集的依赖
 * @param key ref 或 reactive 对象
 */
function recycleDepend(...keys) {
  function _recycleDepend(key) {
    const obj = toRaw(key);
    for (const prop in obj) {
      const val = obj[prop];
      utils.isMemoryObject(val) && _recycleDepend(val);
    }
    funcsMap.delete(obj);
  }
  utils.customForEach(keys, _recycleDepend);
}

/**
 * 将对象转为只读
 * @param target
 * @returns
 */
function readonly(target) {
  Reflect.defineProperty(target, ReactiveFlags.IS_READONLY, {
    value: true
  });
  return new Proxy(target, {
    get(target, key) {
      if (key === ReactiveFlags.RAW) return target; // 返回原始值
      return Reflect.get(target, key);
    },
    set(target, key, value) {
      const oldValue = Reflect.get(target, key);
      return oldValue;
    },
    deleteProperty(target, key) {
      const oldValue = Reflect.get(target, key);
      return oldValue;
    }
  });
}
/**
 * 检测是否为 readonly 对象
 * @param proxy
 * @returns
 */
function isReadonly(proxy) {
  return proxy && readonly(proxy)[ReactiveFlags.IS_READONLY];
}

const rawMap = new WeakMap();
const updateKeysMap = new WeakMap();
const ReactiveFlags = {
  RAW: Symbol('__v_raw'),
  IS_READONLY: Symbol('__v_isReadonly')
};
/**
 * 将数据变为响应式数据（深度）
 * @param target
 * @returns
*/
function reactive(target) {
  if (!utils.isMemoryObject(target) || Object.isFrozen(target)) {
    return target;
  }
  if (rawMap.get(target)) return target;
  let backupKey = null; // 备份当前改变的 key
  return new Proxy(target, {
    // 获取
    get(target, key, receiver) {
      if (key === ReactiveFlags.RAW) return target; // 返回原始值
      const result = Reflect.get(target, key, receiver);
      dependencyCollection(target);
      return utils.isMemoryObject(result) ? reactive(result) : result;
    },
    // 赋值/修改
    set(target, key, value, receiver) {
      if (target[ReactiveFlags.IS_READONLY]) return true;
      const oldValue = Reflect.get(target, key, receiver);
      if (oldValue === value) return true;
      const result = Reflect.set(target, key, value, receiver);
      // 记录要更新的 key
      const updateKeys = updateKeysMap.get(target) || new Set();
      updateKeys.add(key);
      const size = updateKeys.size;
      updateKeysMap.set(target, updateKeys);
      utils.nextTick(() => {
        if (result && size === 1) {
          // console.log(`%c update ${isType(target)}[${key.toString()}]: ${oldValue} --> ${value}`, 'color: orange');
          distributeUpdates(target); // 在同一时刻多次改变数据，只更新一次即可
        }
        updateKeysMap.delete(target); // 更新完成后清除记录
      });
      return result;
    },
    // 删除
    deleteProperty(target, key) {
      const oldValue = Reflect.get(target, key);
      const hasKey = utils.hasOwn(target, key);
      const result = Reflect.deleteProperty(target, key);
      backupKey = key;
      utils.nextTick(() => {
        if (hasKey && result && oldValue !== void 0 && key === backupKey) {
          // console.log(`%c delete ${isType(target)}[${key.toString()}]`, 'color: red');
          distributeUpdates(target);
          backupKey = null;
        }
      });
      return result;
    }
  });
}
/**
 * 判断是否为 reactive 对象
 * @param reactive
 * @returns
 */
function isReactive(reactive) {
  return utils.isObject(reactive) && !!reactive[ReactiveFlags.RAW];
}
/**
 * reactive 对象转普通对象
 * @param reactive
 * @returns
 */
function toRaw(reactive) {
  return isReactive(reactive) ? reactive[ReactiveFlags.RAW] : reactive;
}
/**
 * 检测是否为响应式对象
 * @param proxy
 */
function isProxy(proxy) {
  return isReactive(proxy) || isReadonly(proxy);
}
/**
 * 标记该对象将不能设置为代理对象
 * @param obj
 * @returns
 */
function markRaw(obj) {
  if (utils.isMemoryObject(obj)) rawMap.set(obj, true);
  return obj;
}

function createSignal(value) {
  const raw = {
    value
  };
  const o = reactive(raw);
  function getSignal() {
    return o.value;
  }
  function setSignal(newValue) {
    o.value = newValue;
  }
  return [getSignal, setSignal, raw];
}

const ISREF = '__v_isRef';
class RefImpl {
  [ISREF] = true;
  _rawValue;
  _value;
  getSignal;
  setSignal;
  constructor(value) {
    const [getSignal, setSignal, raw] = createSignal(value);
    this._rawValue = raw;
    this.getSignal = getSignal;
    this.setSignal = setSignal;
    this._value = getSignal();
  }
  get value() {
    return this.getSignal();
  }
  set value(newValue) {
    this.setSignal(newValue);
  }
}
/**
 * 原始值转为响应式数据
 * @param value
 * @returns
 */
function ref(value = void 0) {
  return new RefImpl(value);
}
/**
 * 判断对象是否为 ref
 * @note vue 实现这个函数有点low，随便定义一个对象就可以判断
 * @param ref
 */
function isRef(ref) {
  return ref && !!ref[ISREF];
}
/**
 * 返回 ref 内部值
 * @param ref
 * @returns
 */
function unref(ref) {
  return isRef(ref) ? ref.value : ref;
}
class ObjectRefImpl {
  [ISREF] = true;
  _defaultValue;
  _key;
  _object;
  constructor(target, key, defaultValue = void 0) {
    this._defaultValue = defaultValue;
    this._key = key;
    this._object = target;
  }
  get value() {
    return this._object[this._key];
  }
  set value(value) {
    this._object[this._key] = value;
  }
}
/**
 * @param target
 * @param key
 * @param defaultValue
 * @returns
 */
function toRef(target, key, defaultValue = void 0) {
  return new ObjectRefImpl(target, key, defaultValue);
}
/**
 * @param target
 * @returns
 */
function toRefs(target) {
  const obj = {};
  for (const key in target) {
    obj[key] = new ObjectRefImpl(target, key);
  }
  return obj;
}
class CustomRefImpl extends RefImpl {
  _get;
  _set;
  constructor(callback) {
    let isRef = false;
    const {
      get,
      set
    } = callback(() => isRef = true, () => this.setValue());
    super(get());
    this.__v_isRef = isRef;
    this._get = get;
    this._set = set;
  }
  get value() {
    return this.__v_isRef ? super.value : this._get();
  }
  // 方法重写，阻断，将 val 指给 set 函数
  set value(val) {
    this._set(val);
  }
  /**
   * 设置 value，在合适的时间调用
   */
  setValue() {
    super.value = this._get();
  }
}
/**
 * 自定义 Ref
 * @param callback
 * @returns
 */
function customRef(callback) {
  return new CustomRefImpl(callback);
}

class ReactiveEffect {
  fn;
  constructor(fn) {
    this.fn = fn;
  }
}

class ComputedRefImpl {
  __v_isReadonly = true;
  [ISREF] = true;
  _cacheable = true;
  _dirty = true;
  computed;
  _setter;
  constructor(getter, setter) {
    this.computed = new ReactiveEffect(getter);
    this._setter = setter;
  }
  get value() {
    return this.computed.fn();
  }
  set value(val) {
    if (this._setter) {
      this._setter(val);
    }
  }
}
/**
 * 计算属性
 * @param option
 * @returns
 */
function computed(option) {
  if (utils.isFunction(option)) {
    return new ComputedRefImpl(option);
  }
  // @ts-ignore
  return new ComputedRefImpl(option.get, option.set);
}

/**
 * 侦听器
 * @param source  响应式数据
 * @param cb      回调函数
 * @param option  配置参数
 * @returns unwatch() 取消监听
 */
function watch(source, cb, option = {}) {
  let cleanup = false;
  if (cleanup) return;
  const oldValue = source();
  option.immediate && cb(oldValue, void 0);
  let backup = utils.deepClone(oldValue);
  let first = true;
  binding(() => {
    if (cleanup) return true;
    const value = source();
    // 是一个对象
    if (utils.isMemoryObject(value)) {
      if (option.deep && !utils.isEquals(value, backup)) {
        cb(value, backup);
        backup = utils.deepClone(value);
      }
      return;
    }
    // 原始值
    if (first) {
      // 第一次不进行回调，上面已经执行过一次
      first = false;
      return;
    }
    if (value !== backup) {
      cb(value, backup);
      backup = value;
    }
  });
  return () => {
    cleanup = true;
  };
}
/**
 * 立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行
 * @param cb
 * @returns stop() 取消监听
 */
function watchEffect(cb) {
  let cleanup = false;
  let lock = false;
  binding(() => {
    if (cleanup) return true;
    cb(cleanupFn => {
      lock && cleanupFn(); // 第一次不执行
      lock = true;
    });
  });
  return () => {
    cleanup = true;
  };
}

exports.binding = binding;
exports.computed = computed;
exports.createSignal = createSignal;
exports.customRef = customRef;
exports.isProxy = isProxy;
exports.isReactive = isReactive;
exports.isRef = isRef;
exports.markRaw = markRaw;
exports.reactive = reactive;
exports.readonly = readonly;
exports.recycleDepend = recycleDepend;
exports.ref = ref;
exports.toRaw = toRaw;
exports.toRef = toRef;
exports.toRefs = toRefs;
exports.unref = unref;
exports.watch = watch;
exports.watchEffect = watchEffect;
