import { toRaw, reactive, ref, watch } from '../reactivity';
import { isString, isBrowser, customFind, customForEach, createId, deepClone, isFunction, len } from '../utils';
import { h, Fragment, onMounted, onUnmounted } from '../vdom';

/**
 * 获取 url query
 * @param url
 * @returns
 */
function parseQuery(url) {
  const query = {};
  url.replace(/([^?&=]+)=([^&]+)/g, (_, k, v) => query[k] = v);
  return query;
}
/**
 * 根据 url 解析 route
 * @param url
 * @returns
 */
function analyzeRoute(url) {
  const newUrl = new URL('http://0.0.0.0' + url);
  return {
    fullPath: newUrl.href.replace(newUrl.origin, ''),
    path: newUrl.pathname,
    query: parseQuery(newUrl.search),
    hash: newUrl.hash,
    meta: {}
  };
}
/**
 * 组织 url
 * @param option
 * @returns
 */
function splicingUrl(option) {
  let search = '';
  for (const key in option.query) {
    if (option.query[key]) {
      search += `${key}=${option.query[key]}&`;
    }
  }
  search = search ? '?' + search.slice(0, -1) : '';
  let hash = option.hash ? '#' + option.hash : '';
  return option.path + search + hash;
}
/**
 * 格式化 url，删除重复的 /
 * @param url
 * @returns
 */
function formatUrl(url) {
  return url.replace(/\/{1,}/g, '/');
}

/**
 * 切换路由
 * @param option
 * @param type 切换类型
 */
function toggle(option, type) {
  if (isString(option)) {
    if (config.mode === 'history') {
      option = config.base + option;
    }
    option = analyzeRoute(option);
  }
  for (const key in option) {
    currentRoute[key] = option[key];
  }
  const fullPath = splicingUrl(currentRoute);
  currentRoute.fullPath = fullPath;
  if (!isBrowser()) return;
  if (config.mode === 'history') {
    history[type === 'push' ? 'pushState' : 'replaceState']({}, '', fullPath);
  } else {
    location.hash = fullPath;
  }
}
/**
 * 向前 push 一个路由
 * @param option
 */
function push(option) {
  toggle(option, 'push');
}
/**
 * 替换当前路由
 * @param option
 */
function replace(option) {
  toggle(option, 'replace');
}
/**
 * 向前/后改变路由
 * @param num
 */
function go(num) {
  history.go(num);
}
/**
 * router method
 * @returns
 */
function useRouter() {
  return {
    back: () => go(-1),
    forward: () => go(1),
    go,
    push,
    replace,
    options: config,
    currentRoute: toRaw(currentRoute)
  };
}
/**
 * 当前 route 信息
 * @returns
 */
function useRoute() {
  return currentRoute;
}

const config = {
  base: '',
  mode: 'history',
  ssrDataKey: 'g_initialProps'
};
let currentApp = null;
let currentRoute = null;
/**
 * 获取浏览器 url
 * @returns
 */
function getBrowserUrl() {
  const {
    origin,
    href,
    hash
  } = location;
  if (config.mode === 'hash') {
    return hash.replace('#', '');
  }
  return href.replace(origin + config.base, '');
}
let beforeEach = null;
/**
 * 初始化路由
 * @param option
 * @returns
 */
function createRouter(option = {}) {
  Object.assign(config, option);
  if (isBrowser()) {
    const route = analyzeRoute(getBrowserUrl());
    currentRoute = reactive(route);
    window.addEventListener('popstate', () => {
      const route = analyzeRoute(getBrowserUrl());
      for (const key in route) {
        currentRoute[key] = route[key];
      }
    });
  } else {
    // 随便给个路径，防止报错。真正的路径在 ssrOutlet 赋值
    currentRoute = analyzeRoute('');
  }
  const router = useRouter();
  return {
    install(app) {
      currentApp = app;
      app.$router = router;
      app.$route = useRoute();
    },
    ...router,
    beforeEach(func) {
      beforeEach = func;
    }
  };
}
// 服务端临时变量
const variable = {
  currentTemplate: '',
  ssrData: {}
};

function Route(props) {}
/**
 * 查找路由
 * @param routes
 * @param pathname
 * @returns
 */
function queryRoute(routes, pathname) {
  pathname = pathname.replace(config.base, '');
  const query = customFind(routes, val => {
    const {
      path,
      exact
    } = val.attrs;
    if (exact === false) {
      return (pathname + '/').startsWith(formatUrl(path + '/'));
    }
    return formatUrl(path) === pathname;
  });
  if (!query) return;
  const {
    path,
    component,
    beforeEnter,
    meta,
    redirect
  } = query.attrs;
  // 重定向
  if (redirect) return queryRoute(routes, redirect);
  return {
    path: formatUrl(path),
    component,
    meta,
    beforeEnter
  };
}

let backupRoute = void 0; // 旧的 route 信息
const unwatchs = []; // 收集子路由的取消监听事件
function BrowserRouter(props) {
  const Comp = ref(props.loading);
  let attrs = {};
  function routeChange(path) {
    const query = queryRoute(props.children, path);
    if (!query) {
      attrs = {};
      Comp.value = props.notFound;
      return;
    }
    /**
     * 渲染组件
     */
    async function next() {
      // 按需加载组件
      if (!query.component.prototype) {
        query.component = (await query.component()).default;
      }
      // 组件没有发生变化
      if (Comp.value === query.component) return;
      attrs.path = query.path;
      const getInitialProps = isExistGetInitialProps(query.component);
      if (getInitialProps) {
        const ssrData = window[config.ssrDataKey];
        if (ssrData && attrs.path in ssrData) {
          attrs.data = ssrData[attrs.path];
          delete ssrData[attrs.path];
        } else {
          attrs.data = await getInitialProps(deepClone(attrs));
        }
      }
      Comp.value = query.component;
      attrs.meta = query.meta;
      currentRoute.meta = query.meta;
    }
    function protect(func) {
      func(toRaw(currentRoute), backupRoute, () => {
        backupRoute = deepClone(currentRoute);
        path === currentRoute.path ? next() : routeChange(currentRoute.path);
      });
    }
    // 全局守卫
    if (beforeEach) {
      protect(beforeEach);
      return;
    }
    // 独享守卫
    if (query.beforeEnter) {
      protect(query.beforeEnter);
      return;
    }
    backupRoute = deepClone(currentRoute);
    next();
  }
  const unwatch = watch(() => currentRoute.path, value => {
    // 父级组件卸载的时候，需要把嵌套路由的监听器全部取消掉（这里存在性能问题）
    if (backupRoute) {
      const arr1 = backupRoute.path.split('/'),
        arr2 = value.split('/');
      if (arr1[1] !== arr2[1]) {
        customForEach(unwatchs, unwatch => unwatch());
      }
    }
    routeChange(value);
  }, {
    immediate: true
  });
  props.prefix && unwatchs.push(unwatch);
  return h(Fragment, null, () => Comp.value && h(Comp.value, {
    ...attrs
  }));
}
const stack = reactive([]); // 执行栈
function deleteStackItem(id) {
  const index = stack.indexOf(id);
  stack.splice(index, 1);
}
let repalceComp = null;
function StaticRouter(props) {
  function routeChange(path) {
    let query = queryRoute(props.children, path);
    if (!query) return;
    currentRoute.path = query.path;
    function protect(func) {
      repalceComp = `b_${createId()}`;
      stack.push(repalceComp);
      func(toRaw(currentRoute), backupRoute, () => {
        backupRoute = deepClone(currentRoute);
        resultReplace(repalceComp, query.component, {
          path: query.path,
          meta: query.meta
        });
        deleteStackItem(repalceComp);
      });
      return repalceComp;
    }
    // 全局守卫
    if (beforeEach) return protect(beforeEach);
    // 独享守卫
    if (query.beforeEnter) return protect(query.beforeEnter);
    return query;
  }
  let query = routeChange(currentRoute.path);
  if (isString(query)) {
    return h(Fragment, null, query);
  }
  if (!query) {
    const Comp = props.notFound;
    return Comp ? h(Comp, null) : h(Fragment, null);
  }
  query = query;
  let Comp = query.component;
  currentRoute.path = query.path;
  currentRoute.meta = query.meta;
  const attrs = {
    path: query.path,
    meta: query.meta
  };
  if (repalceComp) {
    resultReplace(repalceComp, Comp, attrs);
    deleteStackItem(repalceComp);
  }
  const replaceStr = `r_${createId()}`;
  // 如果是异步组件
  if (!Comp.prototype) {
    stack.push(replaceStr);
    Comp().then(async res => {
      Comp = res.default;
      // 存在 getInitialProps
      const getInitialProps = isExistGetInitialProps(Comp);
      if (getInitialProps) {
        attrs.data = await getInitialProps(deepClone(attrs));
        variable.ssrData[attrs.path] = attrs.data;
      }
      // 替换结果
      resultReplace(replaceStr, Comp, attrs);
    });
    return h(Fragment, null, replaceStr);
  }
  // 存在 getInitialProps
  const getInitialProps = isExistGetInitialProps(Comp);
  if (getInitialProps) {
    stack.push(replaceStr);
    getInitialProps(deepClone(attrs)).then(res => {
      attrs.data = res;
      variable.ssrData[attrs.path] = res;
      // 替换结果
      resultReplace(replaceStr, Comp, attrs);
    });
    return h(Fragment, null, replaceStr);
  }
  return h(Comp, {
    ...attrs
  });
}
/**
 * BrowserRouter & StaticRouter
 * @param props
 * @returns
 */
function Router(props) {
  customForEach(props.children, val => {
    if (props.prefix) {
      val.attrs.path = formatUrl(props.prefix + val.attrs.path);
    }
    val.children = [val.attrs.component];
  });
  return isBrowser() ? h(BrowserRouter, {
    ...props
  }) : h(StaticRouter, {
    ...props
  });
}
/**
 * 结果替换
 * @param replaceStr
 * @param Comp
 * @param attrs
 */
function resultReplace(replaceStr, Comp, attrs) {
  const string = currentApp.renderToString(h(Comp, {
    ...attrs
  }));
  deleteStackItem(replaceStr);
  const newTemplate = variable.currentTemplate.replace(replaceStr, string);
  variable.currentTemplate = newTemplate;
}
/**
 * 是否存在 getInitialProps 属性并且能运行
 * @param Comp
 * @returns 如果能运行返回 getInitialProps 本身
 */
function isExistGetInitialProps(Comp) {
  const {
    getInitialProps
  } = Comp.prototype;
  if (getInitialProps && isFunction(getInitialProps)) {
    return getInitialProps;
  }
}

function Link(props) {
  const {
    to,
    type,
    className,
    children,
    onClick,
    ...args
  } = props;
  const route = useRoute();
  if (!isString(to)) {
    props.to = splicingUrl(Object.assign({}, route, to));
  }
  const href = config.mode === 'hash' ? `${config.base}#${props.to}` : config.base + props.to;
  function jump(e) {
    e.preventDefault();
    function next(to = props.to) {
      type === 'replace' ? replace(to) : push(to);
    }
    if (onClick) {
      onClick(props.to, next);
    } else {
      next();
    }
  }
  const currentPath = props.to + '/';
  return h("a", {
    className: [() => (route.path + '/').startsWith(currentPath) && 'active', () => route.path + '/' === currentPath && 'exact-active', ...[className].flat()],
    href: href,
    onclick: jump,
    ...args
  }, children);
}

function Helmet(props) {
  const regs = [];
  customForEach(props.children, tree => {
    if (tree.tag === 'title') {
      regs.push(new RegExp('<title'));
    } else if (tree.tag === 'meta' && tree.attrs.name) {
      regs.push(new RegExp(`<meta name=("|')?${tree.attrs.name}`));
    }
  });
  // 服务端
  if (variable.currentTemplate) {
    const matched = variable.currentTemplate.match(/\<head\>(.*)\<\/head>/s);
    const headInnerHTML = matched[1].trim();
    const nodes = headInnerHTML.split('\n').filter(val => val.includes('<'));
    for (let i = 0; i < len(nodes); i++) {
      nodes[i] = nodes[i].trim();
      for (let j = 0; j < len(regs); j++) {
        if (regs[j].test(nodes[i])) {
          nodes[i] = '';
        }
      }
    }
    customForEach(props.children, val => {
      const html = currentApp.createHTML(val);
      nodes.push(html);
    });
    const newHeadInnerHTML = nodes.filter(val => val).join('\n');
    variable.currentTemplate = variable.currentTemplate.replace(/\<head\>.*\<\/head>/s, `<head>\n${newHeadInnerHTML}\n</head>`);
  }
  // #region 客户端
  let backupChild = []; // 备份原先的字节点
  let count = 0; // 更换新的节点个数
  onMounted(() => {
    const head = document.head;
    const nodes = head.innerHTML.split('\n').filter(val => val.includes('<'));
    const removes = []; // 删除项
    tag: for (let i = 0; i < len(regs); i++) {
      for (let j = i; j < len(nodes); j++) {
        if (regs[i].test(nodes[j])) {
          removes.push(i);
          continue tag;
        }
      }
    }
    customForEach(removes, val => {
      backupChild.push(head.children[val].cloneNode(true));
      head.children[val].remove();
    });
    count = len(props.children);
    const node = currentApp.createNodeFragment(props.children);
    head.insertBefore(node, head.children[0]);
  });
  // 恢复原先的节点
  onUnmounted(() => {
    const head = document.head;
    for (let i = 0; i < count; i++) {
      head.children[0].remove();
    }
    customForEach(backupChild, node => {
      head.insertBefore(node, head.childNodes[0]);
    });
  });
  // #endregion
  return h(Fragment, null);
}

export { Helmet, Link, Route, Router, createRouter, useRoute, useRouter };
